#+TITLE: Scheme
#+AUTHOR: fran
#+DESCRIPTION: Pasando a limpio lo que aprendí de distintas fuentes sobre SCHEME
#+BIBLIOGRAPHY: Hal Abelson, Gerald Jay Sussman - Structure and Interpretation of Computer Programs.
#+PROPERTY: header-args:scheme :session fran-scheme :exports both
#+OPTIONS: num:nil
* Construyendo Abstracciones con Procedimientos
** Elementos de la programación
Todo lenguaje de programación debe proveer medios para la construcción de ideas complejas a partir de ideas simples, por ello todo lenguaje cuenta con tres mecanismos para lograrlo:

*Expresiones Primitivas:* las entidades mas simples que maneja el lenguaje, int, float, etc.

*Métodos de Combinación:* elementos complejos son construidos a partir de elementos mas simples.

*Métodos de Abstracción:* elementos complejos pueden ser nombrados y tratados como unidades.

*** Expresiones
Scheme (como todo dialecto lisp), utiliza notación polaca, expresiones primitivas como suma, números, etc. se pueden combinar para formar *combinaciones*, estas están formadas por una *lista de expresiones*, el elemento mas a la izquierda es el *operador*, el resto de elementos son sus *operandos*, cada operando puede ser a su vez otra combinación permitiendo a las combinaciones estar *anidadas*, en principio no hay limite de la profundidad del anidamiento:

#+begin_src scheme :eval no
                                          ; Expresiones primitivas
  1
  5
                                          ; Expresiones combinadas
  (+ 5 1)
  (* 5 4 3 2)
                                          ; Expresiones anidadas
  (+ (* 3
        (+ 100 50))
     (* 1 1)
     (* 1 1))
#+end_src

#+RESULTS:
: 452

Para la definición de *variables*, la función /define/ nos permite nombrar algo en el *entorno global*, se puede definir en distintos entornos.
*** TODO Agregar otras definiciones de variables en diferentes entornos
#+begin_src scheme :session none
  (define variable "Hola mundo")
  variable
#+end_src

#+RESULTS:
: Hola mundo

Notar que (define x y) no es una combinación, ya que no aplica el operador a sus operandos, sino que los asocia, dichas excepciones son llamadas *formas especiales*. Cada forma especial tiene su propia regla de evaluación.

*** Procedimientos Compuestos
Para definir procedimientos en Scheme, de nuevo utilizamos /define/. Ej potencia 2:

#+begin_src scheme
  (define (cuadrado x) (* x x))  
  (define (cubo a) (* a a a))
  (cuadrado 2)
#+end_src

#+RESULTS:
: 4

La forma general para definir un procedimiento es:
#+begin_src scheme :eval no
  (define (<nombre> <parametros formales>)
    (<cuerpo>))
#+end_src

El /nombre/ es un símbolo asociado a la definición del procedimiento en el entorno. Los /parámetros formales/ son los nombres utilizados dentro del cuerpo del procedimiento. El /cuerpo/ es una expresión que producirá un resultado en el momento que los parámetros formales se reemplacen por los reales. El nombre y los parámetros formales son agrupados entre paréntesis justo como seria la llamada real al procedimiento.

Ej x^2 + y^2:

#+begin_src scheme
  (define (suma-de-cuadrados x y)
    (+ (cuadrado x) (cuadrado y)))

  (suma-de-cuadrados 3 4)
#+end_src

#+RESULTS:
: 25

*Orden Aplicativo vs Orden Normal*

Como habíamos dicho Scheme evalúa primero el operador y los operandos, luego aplica el procedimiento resultante a los argumentos resultantes. Podemos pedirle a Scheme un método alternativo, que no evalué los argumentos hasta que sea necesario.

El *orden normal*, primero expande toda la combinación hasta que solo quedan primitivas, luego realiza la evaluación.

/Primero expande luego reduce./

Ej:

#+begin_src scheme :eval no
                                          ; Expande
  (suma-de-cuadrados 3 4)
  (+ (cuadrado 3) (cuadrado 4))
  (+ (* 3 3) (* 4 4))
                                          ; Reduce
  (+ (9) (16))
  (25)
#+end_src

Mientras que el *orden aplicativo* va evaluando las expresiones primitivas mas anidadas primero y luego evaluando los resultados con el siguiente operador.

Ej:

#+begin_src scheme :eval no
  (suma-de-cuadrados 3 4)
  (+ (cuadrado 3) (cuadrado 4))
  (+ (* 3 3) (cuadrado 4))
  (+ 9 (cuadrado 4))
                                          ; .....

  (25)
#+end_src

Scheme utiliza el modo aplicativo por defecto principalmente por la eficiencia adicional obtenida al eludir múltiples evaluaciones de expresiones del tipo (+ x y) (* x y) y mas importante, la evaluación en orden normal se vuelve mas compleja de tratar cuando dejamos el reino de los procedimientos que pueden ser modelados con substituciones.

*** Expresiones Condicionales y Predicados

Los *condicionales* en scheme se utilizan de la siguiente manera:

#+begin_src scheme :eval no
  (cond (<p1> <e1>) (<p2> <e2>) ... )
#+end_src

Donde pi es el *predicado* y ei la *expresión* resultante si pi es verdadero, el par /(<pi> <ei>)/ es llamado *clausula*. Veamos un ejemplo con el valor absoluto:

#+begin_src scheme 
  (define (abs x)
    (cond ((> x 0) 0)
          ((= x 0) 0)
          ((< x 0) (- x))))

  (abs (- 20))
#+end_src

#+RESULTS:
: 20

Scheme evalúa cada uno de los predicados en orden, retorna la expresión del primer predicado en evaluar verdadero, si no hay, la condición es /indefinida/. Se puede utilizar *else* en la clausula final de una condición, esto causa que else retorne la expresión asociada cuando ningún otro predicado fue verdadero.

#+begin_src scheme 
  (define (abs x)
    (cond ((< x 0) (- x))
          (else x)))

  (abs (- 20))
#+end_src

#+RESULTS:
: 20

También podemos usar *if*, la forma general de una expresión if es:

#+begin_src scheme :eval no
  (if <predicado> <expresion_v> <expresion_f>)
#+end_src

Scheme cuenta con operaciones lógicas que permiten construir predicados compuestos:

#+begin_src scheme :eval no
  (and ⟨e1⟩ . . . ⟨en⟩)
  (or ⟨e1⟩ . . . ⟨en⟩)
  (not ⟨e⟩)
#+end_src

Notar que tanto /or/ como /and/ son formas especiales, no procedimientos, ya que las subexpresiones no necesariamente son todas evaluadas.

#+begin_src scheme 
  (define (>= x y)
    (or (> x y) (= x y)))

  (define (<= x y)
    (not (> x y)))

  (<= 2 2)
#+end_src

#+RESULTS:
: #t

En matemáticas generalmente nos enfocamos a *descripciones declarativas* /que es/, mientras que en computación nos interesan las *descripciones imperativas* /como hacer/.

Ej: /raiz(x) = y/, donde /y >= 0/ y /x = y*y/

No nos dice como obtener el numero /y/ que cumple dicha condición, podemos aproximar un resultado con el método de newton:

/xn+1 = xn - f(xn)/f'(en)/,

#+begin_src scheme
  (define (raiz-newton aprox x)
    (if (buena-aprox? aprox x)
        aprox
        (raiz-newton (mejorar-aprox aprox x) x)))

  (define (mejorar-aprox aprox x)
    (promedio aprox (/ x aprox)))

  (define (promedio x y)
    (/ (+ x y) 2))

  (define (buena-aprox? aprox x)
    (< (abs (- (cuadrado aprox) x))
       0.0001))

  (raiz-newton 4 17)
#+end_src

#+RESULTS:
: 2177/528

*** Procedimientos: abstracciones caja negra

*Nombres Locales*
Al definir procedimientos, los nombres que utilizamos en los parámetros formales son llamados *variables vinculadas*, dichas variables son locales al cuerpo de la defunción del procedimiento, por ejemplo en raiz-newton nuestras variables vinculadas serian /aprox, y, x/.
Sin embargo /if, buena-aprox?/, etc. no son locales a dicha definición, son llamadas *libres*, que pasa si tenemos un sistema grande y contamos con varios procedimientos /buena-aprox/ diferentes?.

*Definiciones internas y estructura de bloques*
Para solucionar el problema nombrado contamos con *subprocedimientos*, definiéndolos internamente en un bloque:

#+begin_src scheme
  (define (promedio x y) (/ (+ x y) 2))

  (define (raiz-newton aprox x)
    (define (mejorar-aprox aprox)
      (promedio aprox (/ x aprox)))
    (define (buena-aprox? aprox)
      (< (abs (- (cuadrado aprox) x))
         0.0001))
    (if (buena-aprox? aprox)
        aprox
        (raiz-newton (mejorar-aprox aprox) x)))

  (raiz-newton 4 19)

#+end_src

#+RESULTS:
: 11916881/2733920


Ahora /mejorar-aprox/ y /buena-aprox/ son subprocedimientos locales a raiz-newton, si mas adelante tenemos funciones de evaluación de aproximaciones diferentes no van a interferir en nuestro procedimiento.

** Procedimientos y los procesos que generan

Un procedimiento es un patrón para la *evolución local* de un proceso computacional. Especifica como cada etapa del proceso es construida sobre la anterior. Nos gustaría ser capaces de hacer afirmaciones globales sobre el comportamiento global del proceso, cuya evolución local ya ha sido especificada por un procedimiento.

*** Recursión Linear e Iteraciones
Cuando realizamos recursión en Scheme, el proceso construye una cadena de *operaciones diferidas*, ya que tiene que expandir de nuevo el procedimiento y mantener la información de la operación del procedimiento anterior
#+begin_src scheme 
  (define (factorial n)
    (if (= n 1)
        1
        (* n (factorial (- n 1)))))

  (factorial 5)
#+end_src

#+RESULTS:
: 120

Este ej ejecutará de la sig manera:

#+begin_src scheme :eval no
  (* 5 ( factorial 4))

  (* 5 (* 4 (factorial 3)))
  ...
  (* 5 (* 4 (* 3 (* 2 (1)))))
#+end_src

Podemos hacerlo de forma iterativa, devolviendo la evaluación del siguiente paso con los parámetros reales, solo manteniendo la información de los operandos, sin tener que crear una lista de operaciones diferidas:

#+begin_src scheme 
  (define (factorial producto contador max-cant)
    (if (> contador max-cant)
        producto
        (factorial (* producto contador) (+ contador 1) max-cant)))

  (factorial 1 1 5)
#+end_src

#+RESULTS:
: 120

De forma interactiva la ejecución es:

#+begin_src scheme :eval no
  (factorial 1 1 5)
  (factorial 1 2 5)
  (factorial 2 3 5)
  (factorial 6 4 5)
  ...
#+end_src

La mayoría de lenguajes están diseñados de forma que la interpretación de procedimientos recursivos consumen una cantidad creciente de memoria con cada llamada, incluso cuando el proceso que describe es iterativo. Scheme permite ejecutar un proceso iterativo en un espacio constante incluso si es descrito por un procedimiento recursivo. Dichas implementaciones con esta propiedad se llaman *cola-recursiva*.

*** Árbol Recursivo
Cuando tenemos múltiples llamadas recursivas en nuestros procedimientos, la ejecución del procedimiento tendrá una forma de árbol, el cual crece de manera exponencial.
#+begin_src scheme 
  (define (fib n)
    (if (< n 2)
        n
        (+ (fib (- n 1)) (fib (- n 2)))))

  (fib 5)
#+end_src

#+RESULTS:
: 5

[[file:./Imagenes/fib.png]]

Otro ejemplo de árbol recursivo y una variante iterativa

#+begin_src scheme 
  (define (f n)
    (if (< n 3)
        n
        (+ (f (- n 1))
           (* 2 (f (- n 2)))
           (* 3 (f (- n 3))))))

  (f 20)
#+end_src

#+RESULTS:
: 10771211


#+begin_src scheme
  (define (f-iter n)
    (define (f-iter-aux n i a b c)
      (if (< n 3)
          n
          (if (< i n)
              (f-iter-aux n
                          (+ i 1)
                          b c
                          (+ c (* 2 b) (* 3 a)))
              c)))
    (f-iter-aux n 2 0 1 2))

  (f-iter 20)

#+end_src

#+RESULTS:
: 10771211

** Formulando Abstracciones con Procedimientos de Orden Superior
Los procedimientos que toman otros procedimientos como parámetros son llamados *procedimientos de orden superior*, en esta sección veremos como los procedimientos de orden superior son herramientas de abstracción muy poderosas.

*** Procedimientos como Argumentos
Algunos procedimientos tienen patrones en común, por ejemplo si quisiéramos sumar los números dentro de un rango o sus potencias, en ambos procedimientos realizamos una suma recorriendo un intervalo.

En matemáticas dicho patrón ya ha sido identificado hace tiempo, es una *suma de series*, creando la notación sigma: 

∑n=a,b f(n) = f(a) + .. + f(b)

El poder de la notación sigma es que permite a los matemáticos tratar con el concepto de sumatoria en vez de solamente con sumas particulares.

De manera similar como diseñadores, nos gustaría contar con un lenguaje lo suficientemente poderoso que nos permita escribir procedimientos que traten la idea de sumatoria antes de procedimientos que calculan sumas particulares. En Scheme esto se puede hacer fácilmente:

#+begin_src scheme
  (define (sumatoria fun-f a b fun-sig)
    (if (> a b)
        0
        (+ (fun-f a)
           (sumatoria fun-f (fun-sig a) b fun-sig))))

  (define (incrementar-dos a) (+ a 2))
  (define (incrementar-uno a) (+ a 1))

  (sumatoria + 0 100 incrementar-dos)
  (sumatoria cubo 0 100 incrementar-uno)
#+end_src

#+RESULTS:
: 25502500

Aproximemos pi
#+begin_src scheme 
  (define (pi-fun x) (/ 1.0 (* x (+ x 2))))
  (define (pi-sig x) (+ x 4))

  (* (sumatoria pi-fun 1 1000 pi-sig) 8)
#+end_src

#+RESULTS:
: 3.139592655589783


*** Procedimientos usando /lambda/
En vez de estar definiendo uno a uno procedimientos como /incrementar-x, pi-sig, pi-fun, etc./ podemos describir lo que queremos utilizando la forma especial *lambda*:

#+begin_src scheme
  ;; Veamos la sumatoria de cubos de los numeros pares entre 0 100
  (sumatoria (lambda (x) (* x x x))
             0
             100
             (lambda (x) (+ x 2)))

#+end_src

#+RESULTS:
: 13005000

En general lambda es utilizado para crear procedimientos de la misma forma que define, con la excepción que no se lo asocia a ningún nombre del entorno.

#+begin_src scheme :eval no
  (lambda (<parametros-formales>) (<cuerpo>))
#+end_src

#+RESULTS:
: #<procedure 55ccb24c1f38 at <unknown port>:9:23 (<parametros-formales>)>

Otro uso de lambda esta en crear variables locales.
#+begin_src scheme :eval no
  (let ((<var1> <exp1>) .. (<varn> <expn>)) (<cuerpo>))
#+end_src

La primer parte de la expresión *let* es una lista de pares /nombre-expresion/. Cuando let es evaluado, cada nombre es asociado con el valor de la expresión correspondiente. El cuerpo de let es evaluado con dichos nombres asociados como variables locales. La expresión let es interpretada como una alternativa sintáctica a:

#+begin_src scheme :eval no
  ((lambda (<var1> .. <varn>) <cuerpo>) <exp1> .. <expn>)
#+end_src

No se requieren de nuevos mecanismo en el interprete para proveer variables locales. Veamos un ejemplo

#+begin_src scheme :session none
  (define x 5)

  (+ (let ((x 3))
       (* x 3)) ; aca x es local al let, por lo que x=3, let evalua 3*3
     x) ;aca el x es el definido arriba, 5, 5 + let = 5+9 = 14
#+end_src

#+RESULTS:
: 14

*** Procedimientos como valores de retorno
Hemos visto como la habilidad de pasar procedimientos como argumentos incrementa enormemente el poder expresivo de nuestro lenguaje. Podemos mejorar esto aun mas creando procedimientos cuyos valores de retorno sean procedimientos. Veamos un ejemplo, sabemos que la derivada de una función es:

f'(x) = (f(x+dx) - f(x)/dx)

Podemos definir un procedimiento que nos devuelva la derivada de una función.

#+begin_src scheme
  (define dx 0.000000001) ; dx -> 0
  (define (derivada fun)
    (lambda (x) (/ (- (fun (+ x dx)) (fun x)) dx)))

                                          ; como derivada retorna procedimiento (generado por lambda), podemos aplicar su resultado a un valor


  ((derivada cuadrado) 20) ; derivada de x2 es 2x, 2(10) = 20
#+end_src

#+RESULTS:
: 40.00003173132427

* Construyendo Abstracciones con Datos
** Abstracciones de Datos
Construimos *abstracciones de datos* a partir de datos simples uniéndolos en *datos compuestos*. Su objetivo principal es estructurar programas que van a utilizar datos compuestos de forma que operen en "abstracciones de datos".

Esto es, nuestros programas deberían utilizar los datos de manera tal que nos permita no realizar asunciones sobre datos que no sean estrictamente necesarios conocer para realizar la tarea dada. Al mismo tiempo una representación "concreta" es definida independientemente de los programas que la usen como datos. La interfaz entre ambas partes de nuestro sistema sera un conjunto de procedimientos llamados *selectores* y *constructores*.

Veremos como las abstracciones de datos nos permitirán delimitar barreras abstractas entre las diferentes partes de nuestro programa.

Todo lenguaje cuenta con una herramienta que sirva de "pegamento" para unir datos simples, veremos como lograr esto en Scheme sin utilizar operaciones de datos, sino mas bien procedimientos, diluyendo aun mas la distinción entre dato y procedimiento.

Supongamos que queremos realizar procedimientos que realicen las operaciones de suma, resta, etc. en números racionales representados por dos enteros numerador y denominador, asumamos que existen procedimientos /nuevo-racional num den/ que devuelve una abstracción de datos de un numero racional y los procedimientos /numerador x/, /denominador x/ que devuelven el numerador y denominador del numero racional.

Podemos expresar las operaciones como:

#+begin_src scheme 
  (define (suma-racional x y)
    (nuevo-racional (+ (* (numerador x) (denominador y))
                       (* (numerador y) (denominador x)))
                    (* (denominador x) (denominador y))))

  (define (resta-racional x y)
    (nuevo-racional (- (* (numerador x) (denominador y))
                       (* (numerador y) (denominador x)))
                    (* (denominador x) (denominador y))))

  (define (producto-racional x y)
    (nuevo-racional (* (numerador x) (numerador y))
                    (* (denominador x) (denominador y))))

  (define (division-racional x y)
    (nuevo-racional (* (numerador x) (denominador y))
                    (* (denominador x) (numerador y))))

  (define (iguales? x y)
    (= (* (numerador x) (denominador y))
       (* (numerador y) (denominador x))))
#+end_src

#+RESULTS:
: #<unspecified>


Hemos definido operaciones sobre números racionales en términos de procedimientos selectores como /numerador, denominador/ y constructores como /nuevo-racional/.

Para definir estos procedimientos necesitamos abstracciones de datos, para construir dichas abstracciones scheme nos provee del "pegamento" *pares* el cual se define con /cons/, y de los procedimientos primitivos /car/ y /cdr/ que permiten acceder al primer y segundo elemento del par respectivamente:

#+begin_src scheme :session none
  (define x (cons 1 2))
  (car x)
#+end_src

#+RESULTS:
: 1

Ahora si podemos definir los procedimientos /nuevo-raciona, numerador, denominador/:

#+begin_src scheme
  (define nuevo-racional cons)
  (define numerador car)
  (define denominador cdr)

  (iguales? (nuevo-racional 1 2) (nuevo-racional 1 2))
#+end_src

#+RESULTS:
: #t

*** ¿Que se entiende por datos?

Si prestamos atención las abstracciones de datos pueden construirse en base a una serie de procedimientos y condiciones que dichos procedimientos deben cumplir. Por ejemplo, para *dupla* se tiene que cumplir que dados dos objetos x e y, si z es la dupla de ambos objetos, entonces (car z) devuelve x y (cdr z) devuelve y. Podemos realizar nuestra propia implementación de duplas de la siguiente manera:

#+begin_src scheme 
  (define (dupla x y)
    (define (get m)
      (cond ((= m 0) x)
            ((= m 1) y)
            (else (error "El argumento debe ser 0 o 1" m))))
    get)
  (define (car z) (z 0))
  (define (cdr z) (z 1))

  (define x (dupla 5 'holaMundo))
  (x 1)
  (cdr x)
#+end_src

#+RESULTS:
: holaMundo

Los procedimientos de arriba nos permite representar pares sin tener que utilizar datos, prestemos atención que el valor retornado por /par/ es un procedimiento interno llamado get, el cual devuelve x o y si se le pasa como argumento 0 o 1, así mismo /car z/ se define como la aplicación de 0 a z, cdr como la aplicación de 1 a z.

La representación procedimental pese a ser un poco obscura, demuestra que la habilidad de manipular procedimientos como si fuesen objetos automáticamente provee la habilidad de representar datos compuestos. Este estilo de programación es a menudo llamada *pasaje de mensajes*

#+begin_src scheme 
  ;; Otra representacion de dupla

  (define (dupla x y)
    (lambda (m) (m x y)))

  (define (car z)
    (z (lambda (x y) x)))


  (define (cdr z)
    (z (lambda (x y) y)))

  (define dato (dupla 'hola 'mundo))
  (cdr dato)
#+end_src

#+RESULTS:
: mundo

** Datos jerárquicos y la propiedad Clausura
Como hemos visto, las duplas/pares, proveen un "pegamento" primitivo con el cual podemos construir objetos de datos compuestos. De hecho los pares sirven como bloque de construcción universal para diversos tipos de estructuras de datos.

La habilidad de crear pares cuyos elementos sean otros pares es la esencia de la importancia de las listas como herramientas de representación. Nos referimos a esta propiedad como la propiedad *clausura*. En general, una operación que combine objetos de datos satisface la propiedad clausura si el resultado de combinar cosas con dicha operación puede ser usado por la misma operación para crear nuevos datos. Por tanto, la operación clausura nos permite crear objetos de datos jerárquicos, compuestos de otros objetos de datos.

*** Representando secuencias
Una de las estructuras mas útiles que podemos construir con pares es una /secuencia/, una colección ordenada de objetos de datos. Podemos representar una secuencia de muchas formas, la mas directa como un encadenamiento de pares, dicha representación se le llama /lista/:

#+begin_src scheme :session none
  (cons 1
        (cons 2
              (cons 3
                    (cons 4 #nil))))

#+end_src

#+RESULTS:
| 1 | 2 | 3 | 4 |

Scheme provee de primitivas para listas, /list/. Podemos utilizar encadenamientos de car y cdr para acceder a los elementos de dicha lista, utilizamos car para seleccionar el primer elemento de la lista y cdr para obtener su /cola/.

#+begin_src scheme 
  (define mi-lista (list 1 2 3 4))
  (car (cdr (cdr mi-lista)))
#+end_src

#+RESULTS:

Dado que dicho encadenamiento de funciones es algo tedioso de escribir, lisp cuenta con abreviaciones, dichas abreviaciones siempre empiezan y terminan en *c* y *r*, cada *a* y *d* en el medio representa una operación car o cdr.

#+begin_src scheme 
  (caddr mi-lista)
#+end_src

#+RESULTS:
: 3

*** Operaciones de listas
Scheme cuenta con varios procedimientos para manipular listas, por ejemplo /list-ref/ nos devuelve el enésimo elemento de una lista o /length/ que nos devuelve la cantidad de elementos.
#+begin_src scheme
  (length (list 1 2 3 4 5 6 7 8)) ; 8
  (list-ref mi-lista 2)
#+end_src

#+RESULTS:
: 3


El procedimiento /append/ nos permite unir listas
#+begin_src scheme 
  (append mi-lista '(a b c) mi-lista)
#+end_src

#+RESULTS:
| 1 | 2 | 3 | 4 | a | b | c | 1 | 2 | 3 | 4 |

Una operación extremadamente útil para listas es aplicar algún tipo de transformación a cada elemento de la lista

* Algunas implementaciones
** Lista

#+begin_src scheme :session none
  (define (lista . x)
    (if (null? x)
        '()
        (cons (car x) (apply lista (cdr x)))))

  (define (enesimo lista x)
    (if (null? lista)
        '()
        (if (> x 0)
            (enesimo (cdr lista) (- x 1))
            (car lista))))

  (define (largo x)
    (if (null? x)
        0
        (+ 1 (largo (cdr x)))))

  (define (largo-iter x)
    (define (largo-aux a cant)
      (if (null? a)
          cant
          (largo-aux (cdr a) (+ 1 cant))))
    (largo-aux x 0))

  (define (union x y)
    (if (null? x)
        y
        (cons (car x) (union (cdr x) y))))

  (enesimo (lista 1 2 3 4 5) 1)
  (largo-iter (lista 1 2 3 4 5 6 7))
  (union '(1 2 3) '(4 5 6))
#+end_src

#+RESULTS:
| 1 | 2 | 3 | 4 | 5 | 6 |

** Arbol Binario

#+begin_src scheme :session none
  (define (arbol-binario x)())
#+end_src

#+RESULTS:
